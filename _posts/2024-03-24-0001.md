---
layout: single
title: "3. const 자주 사용하기"
categories: effectiveCpp
tag: [Book]
toc: true


---

# Const

외부 변경을 불가능하게 하여 소스코드 수준의 **‘의미적인 제약’**

- 어떤 값이나 객체가 불변이어야 한다는 의도를 보여줄 수 있는 수단
- 클래스 바깥에서는 전역 혹은 네임스페이스 유효 범위의 상수를 선언하는데 쓴다. 
- 파일, 함수, 블록 유효범위에서 static으로 선언한 객체도 `const` 를 붙일 수 있다.
- 클래스 내부의 경우, 정적 멤버 및 비정적 데이터 멤버 모두를 상수로 선언할 수 있다.

​    


## Const 위치에 따른 상수 처리

```c++
char gretting[] = "Hello";
char* p = gretting; // 비상수 포인터, 비상수 데이터
const char* p = gretting; // 비상수 포인터, 상수 데이터
char* const p = gretting; // 상수 포인터, 비상수 데이터터
const char* const p = gretting; // 상수 포인터, 상수 데이터 
```

- `const` 키워드가 * 왼쪽에 있다 ⇒ 포인터가 가리키는 대상이 상수
- `const` 키워드가 * 오른쪽에 있다 ⇒ 포인터 자체가 상수
- `const` 키워드가 양쪽에 있다 ⇒ 대상 및 포인터 둘다 상수

### 포인터가 가리키는 대상을 상수 처리

1. 타입 앞에 `Const`

2. 타입의 뒤쪽이자 * 앞에 `const` 를 붙인다

   ```c++
   void f1(const Widget *pw); // 상수 Widget객체에 대한 포인터를 매개변수로 취함
   void f2(Widget const *pw); // f2도 동일
   ```

​    


## STL 반복자와  T* 포인터

STL반복자는 동작원리가 T*포인터와 매우 흡사하다.

- 어떤 반복자를 `const` 로 선언하는 것은 포인터를 상수로 선언하는 것(`T* const` 포인터)과 같다.
- 반복자는 자신이 가리키는 대상이 아닌 것을 가리키는 경우가 허용되지 않는다. 하지만 가리키는 대상 자체는 변경이 가능하다.
- 변경이 불가능한 객체를 가리키는 반복자가 필요하다면 `const_iterator`를 사용한다.

```c++
std::vector<int> vec;

const std::vector<int>::iterator iter = vec.begin();
*iter = 10; //iter 는 T* const 처럼 동작, iter가 가리키는 대상 변경 가능
++iter; // error! iter는 상수이기 때문에 불가능

std::vector<int>::const_iterator cIter = vec.begin();
*cIter = 10; //const T* 처럼 동작, error! *cIter는 상수
++cIter; // 가능
```

  


## 가장 강력한 Const 용도

함수 선언에 사용하는 경우 가장 강력하게 사용 가능하다.

- 함수 반환 값, 매개 변수, 멤버 함수 앞에 붙을 수 있고 함수 전체에 대해 `const` 의 성질을 붙일 수 있다.
- 함수 반환 값을 상수로 정하면, 안정성과 효율을 지키고 에러를 줄일 수 있다.

```c++
class Rational {};

const Rational operator* (const Rational& lhs, const Rational& rhs);

Rational a,b,c;

( a * b ) = c; //이러한 상황을 방지하기 위해 const 를 반환 값에 붙인 것
```

### 대입연산을 허락했을 때 발생할 수 있는 문제

```c++
if ( a * b = c ) // == 를 하려고 했지만 실수로 = 해버려 대입연산을 해버리는 상황
```

### 문제 방지를 위한 방법

- `operator*`의 반환 값을 `const` 로 정해 놓으면 실수를 미연에 방지할 수 있다.
- 매개변수 혹은 지역 객체를 수정할 일이 없다면, 또는 수정할 수 없게 하려면 `const` 를 가능한 항상 잊지 말고 붙여야 한다.

  


## 상수 멤버 함수

멤버 함수에 붙는 `const` 는 ‘해당 멤버 함수가 상수 객체에 대해 호출될 함수’ 임을 알려준다.

### 상수 멤버 함수가 중요한 이유

1. **클래스의 인터페이스가 이해하기 쉬워진다.**  
   
   이 클래스로 만들어진 객체를 변경할 수 있는 함수는 무엇이고, 변경할 수 없는 함수는 무엇인가를 사용자쪽에서 알고 있어야 한다.
2. **Const 키워드를 통해 상수 객체를 사용할 수 있게 한다.**   
   
   c++의 성능을 높이는 핵심 기법 중 하나가 객체 전달을 ‘ 상수 객체에 대한 참조자’ 로 진행하는 것이다. 이 기법을 잘 이용하려면 상수 상태로 전달된 객체를 조작할 수 있는 `const` 멤버 함수가 준비 되어 있어야 한다는 것이 중요하다.

###   Const 키워드 멤버함수 오버로딩

```c++
class TextBlock
{
public:
	const char& operator[](std::size_t position) const 
	{ return text[position]; } //상수 객체에 대한 operator
	char& operator[](std::size_t position)
	{ return text[position]; } //비상수 객체에 대한 operator
	
private:
	std::string text;
};


TextBlock tb("Hello"); 
std::cout << td[0]; //TextBlock::operator[]의 비 상수 멤버를 호출

const TextBlock ctb("World);
std::cout << ctb[0]; //TextBlock::operator[]의 상수 멤버 호출
```

  


## 상수 객체가 생기는 경우

1. 상수 객체에 대한 포인터
2. 상수 객체에 대한 참조자로 객체가 전달될 때

```c++
void print(const TextBlock& ctb) //ctb는 상수 객체
{
	std::cout << ctb[0]; //TextBlock::operator[]의 상수 멤버 호출

	std::cout << tb[0]; //비상수 TextBlock객체를 읽음
	tb[0] = 'x'; //비상수 버전의 TextBlock 사용
	
	std::cout << ctb[0]; //상수 TextBlock객체를 읽음
	ctb[0] = 'x'; //error! 상수 버전의 TextBlock 사용, 변경 불가능
}
```

`ctb[0] = 'x';` 에서 발생한 에러는 `operator[]` 의 반환타입때문에 생긴것이다.

호출 자체는 문제가 없지만 대입 연산을 시도했기 때문에 에러가 발생했다.

`operator[]`의 비 상수 멤버는 `char`의 참조자를 반환한다. 만약 참조자 없이 `char` 만 쓰게 된다면 사본을 수정하는 것이 되기 때문에 주의해야한다.

​    


## 멤버 함수가 상수 멤버라는 것의 의미

### 비트수준 상수성 ( 물리적 상수성 )

- 어떤 멤버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 않아야 그 멤버 함수가 `const`임을 인정하는 개념이다. 이때 정적 멤버는 제외한다.  
- 즉, 객체를 구성하는 비트들 중 어떤 것도 바꾸면 안된다는 것이다.
- 이때 c++ 에서 정의하는 상수성인 **비트 수준 상수성** 위반을 발견하기 쉽다. 데이터 멤버에 대해 대입 연산이 있는지만 확인하면 된다.

#### 상수 멤버 함수

상수 멤버 함수를 호출한 객체의 어떠한 값도 수정할 수 없다.

그렇지만, `const`가 제대로 동작하지 않아도 검사를 통과하는 멤버 함수들이 있다.

**어떤 포인터가 가리키는 대상을 수정하는 멤버 함수들**이 이 경우에 속한다.

```c++
class CtextBlock
{
public: 
	char& operator[](std::size_t position) const 
	(return pText[position];) // 부적절한 operator[]의 선언
	
private:
	char* pText;
};
```

`operator[]`는 상수 멤버 함수이지만 해당 객체의 내부 데이터에 대한 참조자를 반환한다.

함수 내부에서는 `pText`를 건드리지 않기 때문에 컴파일러를 통과한다. 비트수준 상수성을 지키고 있기 때문이다.

하지만 이로 인해 아래와 같은 문제가 발생한다.

##### 문제 상황

```c++
const CTextBlock cctb("Hello); //상수 객체 선언
char* pc = &cctb[0]; //상수 멤버 함수를 호출 해 내부 데이터의 포인터 얻음

*pc = 'J'; //cctb는 "Jello"를 갖게 됨
```

이런 상황을 보완하는 대체 개념으로 논리적 상수성이 등장했다.

### 논리적 상수성

상수 멤버라고 해서 객체의 한 비트도 수정할 수 없는 것이 아니라 일부 몇 비트는 바꿀 수 있되, 사용자측에서 알아채지 못한다면 상수 멤버 자격이 있다는 것이다.

#### 예시 코드 ( 비트 수준 상수성에 어긋난 코드 )

```c++
class CTextBlock
{
public: 
	std::size_t length() const;

private:
	char* pText;
	std::size_t textLength; //텍스트 길이
	bool lengthIsValid; // 길이의 유효성
};

std::size_t CTextBlock::lengh() const
{
	if(!lengthIsValid)
	{
		textLength = std::strlen(pText); //error! 상수 멤버 함수 안에서 값 대입 불가능
		lengthIsVaild = true; // 값 대입 불가능
	}
	return textLength;
}
```

위의 코드는 비트수준 상수성에 어긋난 코드이다. 이때 수정 방법은 `mutable`을 이용하는 것이다.

#### 해결 방법

```c++
class CTextBlock
{
public: 
	std::size_t length() const;

private:
	char* pText;
	mutable std::size_t textLength; //상수 멤버 함수 내에서 수정 가능 
	mutable bool lengthIsValid; //수정 가능
};

std::size_t CTextBlock::lengh() const
{
	if(!lengthIsValid)
	{
		textLength = std::strlen(pText); //대입 가능
		lengthIsVaild = true; //대입 가능
	}
	return textLength;
}
```

​    


## 상수 멤버 및 비상수 멤버 함수에서 코드 중복을 피하는 방법

`mutable`은 비트 수준 상수성의 문제를 해결할 수 있는 방법이지만, 완전히 해결은 불가능하다.

### 중복 예시코드

```c++
class TextBlock
{
public: 
const char& operaor[](std::size_t position) const
{
	//경계검사
	//접근데이터로깅
	//자료무결성검증
	return text[position];
}

char& operaor[](std::size_t position)
{
	//경계검사
	//접근데이터로깅
	//자료무결성검증
	return text[position];
}

private: 
	std::string text;
};
```

위의 `operator[]`의 상수 버전은 비 상수 버전과 하는 일이 똑같다 단지 반환 타입에 `const` 가 있다는 것만 다를 뿐이다.  

안정성도 유지하면서 코드 중복을 피하는 방법은 비 상수 `operator[]`가 상수 버전의 `operator[]`를 호출하도록 하는것이다.

### 중복을 수정한 예시코드

```c++
class TextBlock
{
public: 
const char& operaor[](std::size_t position) const
{
	//경계검사
	//접근데이터로깅
	//자료무결성검증
	return text[position];
}

char& operaor[](std::size_t position) //상수버전 op[]호출
{
	return const_cast<char&>
	(static_cast<const TextBlock&>(*this)[position]); // const_cast 로 const 제거 후 op[]상수 버전 호출
}

private: 
	std::string text;
};
```

#### 비 상수 버전이 상수 버전을 호출

비 상수 `operator[]`가 상수 버전을 호출하게 하는데 캐스팅이 2번 사용됐다.

그런데 비상수 `operator[]`에서 일반 `operator[]` 라고 적게 되면 자신을 재귀적으로 호출하게 되니 무한 재귀호출을 막기 위해 상수 `operator[]`를 호출하겠다는 것을 `*this`를 사용해 `const` 를 붙여 준 것이다.

`const` 를 붙이는 캐스팅은 **비 상수 객체에서 상수 객체로 바꾸는 것을 강제로 진행**하는 것이므로 `static_cast`를 써도 문제 없다.

#### 상수 버전이 비 상수 버전 호출

상수 멤버 함수는 해당 객체의 논리적 상태를 바꾸지 않겠다는 함수인 반면, 비상수 멤버 함수는 그러한 제약이 없다. 때문에 상수 멤버에서 비상수 멤버를 호출하면 수정하지 않겠다는 **제약을 어기는 상황이 발생**할 수 있다.

실제로 상수 멤버 함수에서 비 상수 멤버 함수를 호출하는 코드를 컴파일 하려면 `const_cast`를 적용해서 `*this`에 붙은 `const` 를 떼어내야 하는데 이것은 큰 문제를 일으킬 수 있다.

#### 비상수에서 상수호출 VS 상수에서 비상수 호출

비 상수 멤버함수 안에서는 객체를 바꾸든 바꾸지 않든 마음대로 할 수 있기 때문에, 상수 멤버함수를 호출한다고 해서 큰 문제가 되지 않는다.

따라서 비 상수 버전에서 상수 버전을 호출 하는 것이 안전하다.  


# 최종 정리

- `const`를 붙여 선언하면 컴파일러가 에러를 파악하는데 도움이 된다. `const` 는 어떤 유효범위에 있는 객체도 붙을 수 있으며, 매개 변수, 반환 타입, 멤버 함수에도 붙을 수 있다
- 컴파일러에서 보면 비트수준 상수성을 지켜야 하지만, 논리적인 상수성을 사용해 프로그래밍 해야한다
- 코드 중복을 피하기 위해 비상수 버전이 상수 버전을 호출하도록 만들어야 한다.





