---
layout: single
title: "2. #define 보단 const, enum, inline"
categories: effectiveCpp
tag: [Book]
toc: true


---



가급적 선행 처리자보다 컴파일러를 더 가까이 하자



## 이유

`#define MYDOUBLE 1.653`

보이는 건 `MYDOUBLE`이 기호식 이름(symbolic name)으로 보이지만 컴파일러에게는 이름으로 보이지 않는다. 소스 코드가 컴파일러로 넘어가기 전에 '선행 처리자' 가 숫자 상수로 바꾸어 버리기 때문이다.

이 결과로 `MYDOUBLE` 은 컴파일러가 쓰는 '기호 테이블' 에 포함되지 않는다. 그래서 상수로 대체된 코드에서 컴파일 에러가 발생하게 된다면 헷갈리는 상황이 발생할 수 있다. 소스 코드엔 `MYDOUBLE`이지만 에러 메세지에는 `1.653` 으로 노출되기 때문이다.

이러한 문제는 마찬가지의 이유로 기호식 디버거(symbolic debugger) 에서도 나타날 소지가 있다. 



## 해결 방법

### 매크로 대신 상수를 사용한다

`const double MyDouble = 1.653` 
언어 차원에서 지원하는 상수 타입의 데이터이기 때문에, 컴파일러가 알 수 있고 기호 테이블에도 추가된다.
또 상수가 부동 소수점 실수 타입일 경우 `#define`을 사용할 때 보다 컴파일을 거친 최종 코드의 크기가 적게 나올 수 있다.
매크로는 `1.653`을 사본 등장 횟수만큼 생성하지만, `const` 상수는 여러 번 사용돼도 사본은 하나만 생성한다.



#### 주의할 점

1. 상수 포인터를 정의하는 경우
   상수는 대개 헤더 파일에 넣는 것이 상례 ( 다른 소스 파일이 이것을 `#include` 하여 사용 )
   따라서 포인터는 꼭 `const`로 선언하고, 포인터가 가리키는 대상까지 `const`로 선언
   예 ) 특정 헤더 파일 안에 `char*` 기반의 문자열 상수를 정의하면 다음과 같이 `const` 를 두 번 사용한다 
   `const char* const authorName = "name";`
   하지만, string 을 사용하는 것이 더 좋음
   `const std::string autorName = "name";`

2. 클래스 멤버로 상수를 정의하는 경우, 즉 클래스 상수를 정의하는 경우
   특정 상수의 유효범위를 클래스로 한정하고자 할 땐 그 상수를 멤버로 만들어야 하는데, 그 상수의 사본 개수가 한 개를 넘지 않길 원한다면 정적(static) 멤버로 생성한다.

   ```c++
   class GamePlayer
   {
   private:
   	static const int Num = 5; // 상수 선언
   	int scores[Num];          // 상수를 사용하는 부분
   }
   ```

   `Num`은 '선언'된 것이다. '정의'가 아니다.

   > *선언 : 이름만 알려준 것*
   > *정의 : 어떤 대상의 이름에 대해 그에 대응하는 메모리 상의 주소를 정한 것*

   정적 멤버로 만들어지는 정수류 타입의 클래스 내부 상수는 주소를 갖는게 아닌 이상, 정의 없이 선언만 해도 문제가 없다. 단, 클래스 상수의 주소를 구하거나, 컴파일러에 따라 '정의' 를 요구한다면 제공 해야 한다.

   클래스 상수의 정의는 구현 ( cpp ) 에 둔다. 

   정의에는 상수의 초기 값이 있으면 안된다. 클래스 상수의 초기 값은 해당 상수가 선언된 시점에 바로 주어진다. 

   

   ##### 주의

    #define은 유효범위를 모르기 때문에 클래스 상수를 `#define`으로 만들면 안된다.
   매크로는 일단 정의되면 컴파일이 끝날 때까지 유효하다는 점을 기억 해야한다.

   즉, `#define`은 클래스 상수를 정의하는 데 쓸 수 없고, 어떤 형태의 캡슐화 혜택도 가질 수 없다. 

   오래된 컴파일러일 경우, 정적 클래스 멤버가 선언된 시점에 초기 값을 주는 것이 맞지 않다고 판단 할 수도 있다. 또 클래스 내부 초기화를 허용하는 경우가 정수 타입의 상수에 대해서만 국한되어 있다. 이때는 초기 값을 상수 '정의' 시점에 주도록 한다.
   
   ```c++
   class CostEstimate 
   {
   private:
       static const double FudgeFactor;           // 정적 클래스 상수의 선언 => 헤더 파일에 둠
   };
   
   const double CostEstimate::FudgeFactor = 1.35; // 정적 클래스 상수의 정의 => 구현 파일에 둠
   ```
   
   ###### 예외 상황
   
   해당 클래스를 컴파일 하는 도중에 클래스 상수의 값이 필요할 때는 예외이다.
   
   `GamePlayer::scores` 등의 배열 멤버를 선언할 경우, 컴파일러는 컴파일 과정에서 배열의 크기를 알아야 하기 때문이다. 때문에 정수 타입의 정적 클래스 상수에 대한 클래스 내 초기화를 금지하는 옛날 컴파일러의 경우 ( 현재 기준으로 옛날 컴파일러는 표준에 어긋남 ) *'나열자 둔갑술( enum hack )'* 이라는 기법을 사용할 수도 있다.
   
   > 나열자 (enumerator) 타입의 값은 int가 놓일 곳에도 쓸 수 있다는 c++의 문법을 활용하는 방법
   
   ```c++
   class GamePlayer
   {
       private:
       enum { NumTruns = 5 };    // 나열자 둔갑술
   
       int scores[ NumTruns ];   // 5에 대한 기호식 이름으로 만듦
   };
   ```
   
   ###### *'나열자 둔갑술'* 을 알아야 하는 이유
   
   - `const`보다 `#define` 에 가까운 동작 방식
   
     `const`의 주소를 잡아내는 것은 합당하지만, `enum`의 주소를 취하는 것은 불가능하다. 또한 `#define` 의 주소를 얻는 것 역시 안된다. 따라서 내가 선언한 정수 상수를 다른 사람이 주소를 얻거나 참조를 하는 것이 싫다면 `enum`이 좋은 방법이 될 것이다. 
   
     제대로 된 컴파일러는 그 객체에 대한 포인터나 참조자를 만들지 않는 한, 정수 타입의 `const` 객체에 대해 저장공간을 준비하지 않는다. ( 컴파일러에 최적화 설정이 되어있으면 `const` 객체는 할당만 하다가 주소나 참소를 썼을때 할당 됨 ) 덜 제대로 된 컴파일러라면 반대로 동작 할 수도 있어서 양쪽 모두 안전하게 `const` 객체에 대한 메모리를 만들지 않는 방법을 쓰는 것도 좋다. 
   
     `enum`은 `#define`처럼 어떤 형태의 쓸데없는 메모리 할당도 절대 저지르지 않는다. 
   
   - 많은 코드에서 이 기법을 사용하기 때문에 발견하면 쉽게 알아보도록 단련하자
     이 기법은 템플릿 메타프로그래밍의 핵심 기법이다.
     아래는 `#define` 의 오용 사례 매크로 함수( 함수처럼 보이지만 호출 오버헤드를 일으키지 않는 매크로 ) 이다. 
   
     ```c++
     // a 와 b 중 큰 것을 f에 넘겨 호출
     #define CALL_WITH_MAX(a,b) f((a) > (b) ? (a) : (b))
     ```
   
     이러한 매크로를 작성할 때에는 괄호를 잊지 말아야 한다. 괄호가 없다면 표현식을 매크로에 넘길 때 문제가 발생할 수 있다. 하지만 괄호만 한다고 해서 완벽한 것은 아니다.
   
     ```c++
     int a = 5, b = 0;
     CALL_WITH_MAX(++a, b);        //a 두 번 증가
     CALL_WITH_MAX(++a, b + 10);   //a 한 번 증가
     ```
   
     f가 호출되기 전 a가 증가하는 횟수가 달라진다. 비교를 통해 처리하는 결과가 어떤 것이냐에 따라 최종 값이 달라지니 문제가 된다. 
   
     이때는 기존 매크로의 효율을 유지하면서 정규 함수의 모든 동작방식 및 타입 안정성까지 완벽히 취할 수 있는 방법의 *인라인 함수* 에 대한 템플릿을 준비한다.
   
     ```c++
     template<typename T>                             // T가 정확히 뭔지 모르기 때문에
     inline void callWithMax(const T& a, const T& b)  // 매개변수로 상수 객체에 대한 참조자 사용
     {
         f( a > b ? a : b );
     }
     ```
   
     이 함수는 템플릿이기 때문에 동일 계열 함수군(family of functions) 을 만들어낸다. 동일한 타입의 객체 두 개를 인자로 받고 둘 중 큰 것을 f에 넘겨 호출한다.
   
     이렇게 되면 함수 본문에 여러 괄호를 칠 필요가 없고, 인자를 여러 번 평가할 지도 모른다는 걱정도 없어진다.
     그뿐 아니라 `callWithMax`는 진짜 함수이기 때문에 유효범위 및 접근 규칙을 그대로 따라간다. 임의의 클래스 안에서만 쓸 수 있는 인라인 함수에 대한 이야기가 나오더라도 전혀 이상하지 않다.
   
     
   
     ## 최종 정리
   
     - 단순한 상수를 쓸 때는, `#define` 보다 `const` 객체 혹은 `enum`을 우선으로 생각한다
     - 함수처럼 쓰이는 매크로를 만드려면, `#define` 매크로보다 인라인 함수를 생각한다
   
     
   
     
